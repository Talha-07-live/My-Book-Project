<!DOCTYPE html>
<html lang="bn">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Advanced Firebase Talha's — Search & Edit</title>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <!-- Tailwind CSS -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">

  <style>
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace }
    pre.json { white-space: pre-wrap; word-break: break-word; background:#f3f4f6; padding:8px; border-radius:6px }
  </style>
</head>
<body class="bg-gray-100 min-h-screen">

  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">

    <!-- Header / Auth -->
    <div class="flex flex-col sm:flex-row sm:items-center justify-between mb-6 gap-4">
      <h1 class="text-xl sm:text-2xl font-bold">Advanced Firebase Talha's Panel</h1>
      <div id="authArea" class="flex flex-col sm:flex-row items-center gap-3 w-full sm:w-auto">
        <div id="userInfo" class="hidden flex items-center gap-3 w-full sm:w-auto">
          <span id="uidLabel" class="mono text-sm"></span>
          <button id="btnLogout" class="bg-gray-700 text-white px-3 py-1 rounded">Logout</button>
        </div>
        <div id="loginBox" class="bg-white p-4 rounded shadow w-full sm:w-96">
          <input id="email" class="border p-2 rounded w-full mb-2" placeholder="Admin email">
          <input id="password" type="password" class="border p-2 rounded w-full mb-2" placeholder="Password">
          <div class="flex flex-col sm:flex-row gap-2">
            <button id="btnLogin" class="bg-blue-600 text-white px-4 py-2 rounded w-full sm:w-auto">Login</button>
            <button id="btnDemo" title="Quick demo" class="bg-gray-200 px-4 py-2 rounded w-full sm:w-auto">Demo</button>
          </div>
          <p id="loginErr" class="text-red-600 text-sm mt-2"></p>
        </div>
      </div>
    </div>

    <!-- Panel -->
    <div id="panel" class="hidden bg-white p-4 rounded shadow">

      <!-- Controls Grid -->
      <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4 mb-4">
        <div>
          <label class="block text-sm font-semibold mb-1">Search Mode</label>
          <select id="mode" class="border p-2 rounded w-full">
            <option value="path">Path / exact key</option>
            <option value="prefix">Key prefix</option>
            <option value="field">Field search</option>
            <option value="full">Full-text</option>
          </select>
        </div>

        <div>
          <label class="block text-sm font-semibold mb-1">Search Query</label>
          <input id="q" class="border p-2 rounded w-full" placeholder="e.g. Attack On Titan OR 720p">
          <div class="text-xs text-gray-500 mt-1">Tip: use short keywords</div>
        </div>

        <div>
          <label class="block text-sm font-semibold mb-1">Options</label>
          <label class="flex items-center gap-2 mb-2"><input type="checkbox" id="searchAllNodes"> Search entire DB</label>
          <div class="flex flex-col sm:flex-row gap-2">
            <button id="btnSearch" class="bg-green-600 text-white px-4 py-2 rounded w-full sm:w-auto">Search</button>
            <button id="btnClear" class="bg-gray-200 px-4 py-2 rounded w-full sm:w-auto">Clear</button>
          </div>
        </div>
      </div>

      <!-- Suggestions -->
      <div class="mb-4">
        <div id="suggestions" class="flex flex-wrap gap-2"></div>
      </div>

      <!-- Summary & Per Page -->
      <div class="mb-4 flex flex-col sm:flex-row justify-between items-start sm:items-center gap-2">
        <div id="summary" class="text-sm text-gray-600">No search yet</div>
        <div class="text-sm text-gray-600">Results per page:
          <select id="perPage" class="border p-1 rounded">
            <option>10</option><option>25</option><option>50</option>
          </select>
        </div>
      </div>

      <!-- Results Table -->
      <div id="resultsWrapper" class="overflow-auto rounded">
        <table class="min-w-full divide-y">
          <thead class="bg-gray-50">
            <tr>
              <th class="px-3 py-2 text-left text-xs font-medium text-gray-500">#</th>
              <th class="px-3 py-2 text-left text-xs font-medium text-gray-500">Path / Key</th>
              <th class="px-3 py-2 text-left text-xs font-medium text-gray-500">Title / preview</th>
              <th class="px-3 py-2 text-left text-xs font-medium text-gray-500">Actions</th>
            </tr>
          </thead>
          <tbody id="resultsTbody" class="bg-white divide-y"></tbody>
        </table>
      </div>

      <!-- Pagination -->
      <div class="mt-4 flex flex-col sm:flex-row justify-between items-start sm:items-center gap-2">
        <div class="flex gap-2">
          <button id="prevPage" class="px-3 py-1 border rounded">Prev</button>
          <button id="nextPage" class="px-3 py-1 border rounded">Next</button>
        </div>
        <div id="pageInfo" class="text-sm text-gray-600"></div>
      </div>

      <!-- Editor Modal -->
      <div id="editorModal" class="fixed inset-0 hidden items-center justify-center bg-black/50 p-4 z-50">
        <div class="bg-white rounded max-w-3xl w-full sm:w-11/12 p-4 overflow-auto max-h-screen">
          <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-2">
            <h3 class="font-semibold">Edit Node: <span id="editPath" class="mono text-sm"></span></h3>
            <div class="flex gap-2">
              <button id="btnApply" class="bg-green-600 text-white px-4 py-1 rounded">Save</button>
              <button id="btnClose" class="bg-gray-200 px-3 py-1 rounded">Close</button>
            </div>
          </div>
          <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <div>
              <label class="text-sm font-semibold">Field Editor (form)</label>
              <div id="fieldForm" class="space-y-2 mt-2"></div>
            </div>
            <div>
              <label class="text-sm font-semibold">Raw JSON (editable)</label>
              <textarea id="rawJson" class="w-full border p-2 rounded h-64 mono"></textarea>
            </div>
          </div>
          <div class="mt-4 flex flex-col sm:flex-row gap-2">
            <button id="btnDelete" class="bg-red-600 text-white px-4 py-1 rounded">Delete Node</button>
            <div id="editorMsg" class="text-sm text-gray-600"></div>
          </div>
        </div>
      </div>

<script>
/* ================= CONFIG ================= */
const firebaseConfig = {
  apiKey: "AIzaSyDpiN0OV1aD709Q987PymfOOp_lcW6Hid8",
  authDomain: "my-book-project-c5a17.firebaseapp.com",
  databaseURL: "https://my-book-project-c5a17-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "my-book-project-c5a17",
  storageBucket: "my-book-project-c5a17.appspot.com",
  messagingSenderId: "422603504433",
  appId: "1:422603504433:web:e6870a7d2c57c045eb0e10",
  measurementId: "G-F763MR7FR9"
};
const ADMIN_UID = "PDK5rMhfUAc2mFA7VwKh3EtItov1";

/* ================ INIT =================== */
firebase.initializeApp(firebaseConfig);
const db = firebase.database();
const auth = firebase.auth();

/* ================ AUTH UI ================ */
const loginBox = document.getElementById('loginBox');
const userInfo = document.getElementById('userInfo');
const uidLabel = document.getElementById('uidLabel');
const btnLogin = document.getElementById('btnLogin');
const btnLogout = document.getElementById('btnLogout');
const loginErr = document.getElementById('loginErr');
const panel = document.getElementById('panel');

auth.onAuthStateChanged(user=>{
  if(user && user.uid === ADMIN_UID){
    loginBox.classList.add('hidden');
    userInfo.classList.remove('hidden');
    uidLabel.textContent = user.uid;
    panel.classList.remove('hidden');
    document.getElementById('loginErr').textContent = '';
  } else {
    loginBox.classList.remove('hidden');
    userInfo.classList.add('hidden');
    uidLabel.textContent = '';
    panel.classList.add('hidden');
  }
});

btnLogin.addEventListener('click', async ()=>{
  loginErr.textContent = '';
  const email = document.getElementById('email').value.trim();
  const password = document.getElementById('password').value.trim();
  if(!email || !password){ loginErr.textContent = 'Enter credentials'; return; }
  try{ await auth.signInWithEmailAndPassword(email, password); }
  catch(err){ loginErr.textContent = err.message; }
});
btnLogout.addEventListener('click', ()=> auth.signOut());
document.getElementById('btnDemo').addEventListener('click', ()=> {
  document.getElementById('q').value = 'Jawan'; // demo
});

/* ================= INDEXEDDB CACHING (kept for editor/offline backup) ================= */
let dbCache = []; // local mirrors when editing/viewing
let idbInstance = null;

function openIDB(){
  if(!('indexedDB' in window)) return Promise.resolve(null);
  if(idbInstance) return Promise.resolve(idbInstance);
  return new Promise((res,rej)=>{
    const req = indexedDB.open('FirebaseCacheV1',1);
    req.onupgradeneeded = ()=> {
      try{
        const dbu = req.result;
        if(!dbu.objectStoreNames.contains('items')) dbu.createObjectStore('items',{keyPath:'path'});
      }catch(e){}
    };
    req.onsuccess = ()=> { idbInstance = req.result; res(idbInstance); };
    req.onerror = ()=> rej(req.error);
  });
}

async function updateIndexedDBItem(item){
  try{
    const idb = await openIDB();
    if(!idb) return;
    const tx = idb.transaction('items','readwrite');
    const store = tx.objectStore('items');
    store.put(item);
  }catch(e){ console.warn('IDB update failed', e); }
}
async function deleteIndexedDBItem(path){
  try{
    const idb = await openIDB();
    if(!idb) return;
    const tx = idb.transaction('items','readwrite');
    const store = tx.objectStore('items');
    store.delete(path);
  }catch(e){ console.warn('IDB delete failed', e); }
}

/* ================== SEARCH CONFIG ================== */
const MAX_PER_QUERY = 500; // each firebase query limit (tune if needed)
const MAX_TOTAL_RESULTS = 2000; // cap combined results shown (protect UI)
const DEFAULT_BASE = '/movies';

/* ================ DOM ELEMENTS ================ */
const qInput = document.getElementById('q');
const modeSelect = document.getElementById('mode');
const btnSearch = document.getElementById('btnSearch');
const btnClear = document.getElementById('btnClear');
const suggestionsDiv = document.getElementById('suggestions');
const resultsTbody = document.getElementById('resultsTbody');
const summary = document.getElementById('summary');
const perPageSel = document.getElementById('perPage');
const prevPage = document.getElementById('prevPage');
const nextPage = document.getElementById('nextPage');
const pageInfo = document.getElementById('pageInfo');

let allHits = []; // [{path,key,data}]
let page = 0;

/* ---------- utility ---------- */
function escapeHtml(s){ return (s+'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }
function debounce(fn, ms=350){
  let t;
  return (...a)=>{ clearTimeout(t); t = setTimeout(()=> fn(...a), ms); };
}

/* ================= FIREBASE QUERY HELPERS (always fresh) ================== */

// Query by child prefix (e.g., title starting with q)
async function queryByChildPrefix(base, child, q, limit = MAX_PER_QUERY){
  try{
    const ref = db.ref(base).orderByChild(child).startAt(q).endAt(q + "\uf8ff").limitToFirst(limit);
    const snap = await ref.get();
    if(!snap.exists()) return [];
    const val = snap.val();
    return Object.keys(val).map(k => ({ path: base.replace(/\/$/,'') + '/' + k, key: k, data: val[k] }));
  }catch(e){
    console.warn('queryByChildPrefix error', child, e);
    return [];
  }
}

// Query by key prefix (order by key)
async function queryByKeyPrefix(base, q, limit = MAX_PER_QUERY){
  try{
    const ref = db.ref(base).orderByKey().startAt(q).endAt(q + "\uf8ff").limitToFirst(limit);
    const snap = await ref.get();
    if(!snap.exists()) return [];
    const val = snap.val();
    return Object.keys(val).map(k => ({ path: base.replace(/\/$/,'') + '/' + k, key: k, data: val[k] }));
  }catch(e){
    console.warn('queryByKeyPrefix error', e);
    return [];
  }
}

// Fetch a single node by exact path (live)
async function fetchByPath(path){
  try{
    const snap = await db.ref(path).get();
    if(!snap.exists()) return null;
    return { path, key: path.split('/').pop(), data: snap.val() };
  }catch(e){ console.error(e); return null; }
}

/* ========== RENDER & PAGINATION ========== */
function setSummary(){
  summary.textContent = `${allHits.length} result(s). Showing page ${page+1}`;
  pageInfo.textContent = `Page ${page+1} / ${Math.max(1, Math.ceil(allHits.length / parseInt(perPageSel.value || 10)))}`;
}

function renderResults(){
  resultsTbody.innerHTML = '';
  const perPage = parseInt(perPageSel.value || 10);
  const start = page * perPage;
  const subset = allHits.slice(start, start + perPage);
  subset.forEach((hit,i)=>{
    const tr = document.createElement('tr');
    const titleHtml = (hit.data && hit.data.title) ? ('<strong>' + escapeHtml(hit.data.title) + '</strong><div class="text-xs text-gray-500">'+ escapeHtml(((hit.data.subtitle||'')+'').toString().slice(0,80)) +'</div>') : ('<pre class="json mono">'+ escapeHtml(JSON.stringify(hit.data)).slice(0,200) +'</pre>');
    tr.innerHTML = `
      <td class="px-3 py-2 text-sm">${start + i + 1}</td>
      <td class="px-3 py-2 mono text-sm">${hit.path}</td>
      <td class="px-3 py-2 text-sm">${titleHtml}</td>
      <td class="px-3 py-2 text-sm">
        <button class="bg-blue-600 text-white px-2 py-1 rounded viewBtn">View</button>
        <button class="bg-yellow-500 text-white px-2 py-1 rounded editBtn">Edit</button>
        <button class="bg-red-600 text-white px-2 py-1 rounded delBtn">Delete</button>
      </td>
    `;
    tr.querySelector('.viewBtn').addEventListener('click', ()=> openEditor(hit.path, hit.data, false));
    tr.querySelector('.editBtn').addEventListener('click', ()=> openEditor(hit.path, hit.data, true));
    tr.querySelector('.delBtn').addEventListener('click', ()=> doDelete(hit.path));
    resultsTbody.appendChild(tr);
  });
  setSummary();
}

/* ========== MAIN SEARCH FLOW (always fresh, safe limits) ========== */
async function doSearch(){
  allHits = [];
  page = 0;
  resultsTbody.innerHTML = '';
  suggestionsDiv.innerHTML = '';
  summary.textContent = 'Searching...';

  const qRaw = (qInput.value || '').trim();
  const q = qRaw.toLowerCase();
  const mode = modeSelect.value;
  const searchAllNodes = document.getElementById('searchAllNodes').checked;
  const base = searchAllNodes ? '/' : DEFAULT_BASE;

  try{
    if(mode === 'path'){
      // try direct path fetch (fresh)
      const pRaw = qRaw;
      const p = pRaw.startsWith('/') ? pRaw : pRaw;
      const maybePaths = [];
      if(p.includes('/')) maybePaths.push(p);
      else {
        maybePaths.push(base.replace(/\/$/,'') + '/' + p);
        maybePaths.push(p);
      }

      for(const mp of maybePaths){
        const r = await fetchByPath(mp);
        if(r) allHits.push(r);
      }

    } else if(mode === 'prefix'){
      // prefer key-based prefix (fast)
      if(!q) {
        // no query: load small sample to show
        const snap = await db.ref(base).orderByKey().limitToFirst(100).get();
        if(snap.exists()){
          const val = snap.val();
          allHits = Object.keys(val).map(k => ({ path: base.replace(/\/$/,'') + '/' + k, key: k, data: val[k] }));
        } else allHits = [];
      } else {
        // query by key prefix
        const byKey = await queryByKeyPrefix(base, q, MAX_PER_QUERY);
        allHits = byKey;
      }

    } else { // field or full (try multiple child queries in parallel, combine)
      if(!q){
        // if empty query, fetch a small page of latest items (prevent huge transfer)
        const snap = await db.ref(base).orderByKey().limitToFirst(200).get();
        if(snap.exists()){
          const val = snap.val();
          allHits = Object.keys(val).map(k => ({ path: base.replace(/\/$/,'') + '/' + k, key: k, data: val[k] }));
        } else allHits = [];
      } else {
        // Try to query common fields by prefix (title, subtitle, maybe rating) - these are efficient.
        const queries = [
          queryByChildPrefix(base, 'title', q, MAX_PER_QUERY),
          queryByChildPrefix(base, 'subtitle', q, Math.floor(MAX_PER_QUERY/2)),
          queryByKeyPrefix(base, q, Math.floor(MAX_PER_QUERY/2))
        ];

        // also try description prefix but smaller limit (descriptions can be huge)
        queries.push(queryByChildPrefix(base, 'description', q, Math.floor(MAX_PER_QUERY/4)));

        const settled = await Promise.allSettled(queries);
        const combined = [];
        for(const s of settled){
          if(s.status === 'fulfilled' && Array.isArray(s.value)){
            for(const item of s.value){
              // use key+path as unique id
              if(!combined.find(x => x.path === item.path)) combined.push(item);
            }
          }
        }

        // If we still have few results (or user used a non-prefix search), do a small client-side scan:
        if(combined.length < 50){
          // fetch a bounded chunk and filter locally for contains-match
          try{
            const snap2 = await db.ref(base).orderByKey().limitToFirst(1000).get(); // bounded scan
            if(snap2.exists()){
              const v2 = snap2.val();
              const arr = Object.keys(v2).map(k=>({ path: base.replace(/\/$/,'') + '/' + k, key: k, data: v2[k] }));
              const filtered = arr.filter(h=>{
                try{
                  const sfull = JSON.stringify(h.data).toLowerCase();
                  return (h.key||'').toLowerCase().includes(q) || sfull.includes(q);
                }catch(e){ return false; }
              });
              for(const it of filtered) if(!combined.find(x=>x.path===it.path)) combined.push(it);
            }
          }catch(e){ console.warn('fallback scan failed', e); }
        }

        // finally set combined (cap results)
        allHits = combined.slice(0, MAX_TOTAL_RESULTS);
      }
    }

    // Prepare suggestions (top 6)
    suggestionsDiv.innerHTML = '';
    allHits.slice(0,6).forEach(h=>{
      const b = document.createElement('button');
      b.className = 'px-3 py-1 bg-gray-100 rounded text-sm';
      b.textContent = h.key + ' → ' + (h.data && h.data.title ? h.data.title : '');
      b.addEventListener('click', ()=> { qInput.value = h.key; modeSelect.value = 'path'; doSearch(); });
      suggestionsDiv.appendChild(b);
    });

    // update dbCache for editor convenience (not used for search)
    dbCache = allHits.slice(0, MAX_PER_QUERY).map(x=>({ path:x.path, key:x.key, data:x.data }));
    // also try to populate indexedDB asynchronously (best-effort)
    try{
      const idb = await openIDB();
      if(idb){
        const tx = idb.transaction('items','readwrite');
        const store = tx.objectStore('items');
        for(const item of dbCache) store.put(item);
      }
    }catch(e){ /* ignore */ }

    renderResults();
  }catch(e){
    console.error(e);
    summary.textContent = 'Error: ' + (e.message || e);
  }
}

/* ========== Editor ========== */
const editorModal = document.getElementById('editorModal');
const editPathLabel = document.getElementById('editPath');
const rawJson = document.getElementById('rawJson');
const fieldForm = document.getElementById('fieldForm');
const btnApply = document.getElementById('btnApply');
const btnClose = document.getElementById('btnClose');
const btnDelete = document.getElementById('btnDelete');
const editorMsg = document.getElementById('editorMsg');

let currentEdit = { path:null, data:null };

function openEditor(path, data, editable=true){
  currentEdit = { path, data: JSON.parse(JSON.stringify(data || {})) };
  editPathLabel.textContent = path;
  rawJson.value = JSON.stringify(currentEdit.data, null, 2);
  buildFieldForm(currentEdit.data);
  editorMsg.textContent = '';
  editorModal.style.display = 'flex';
  editorModal.classList.remove('hidden');
  btnApply.disabled = !editable;
  rawJson.disabled = !editable;
  btnDelete.disabled = !editable;
}

function closeEditor(){ editorModal.style.display = 'none'; editorModal.classList.add('hidden'); }

function buildFieldForm(obj){
  fieldForm.innerHTML = '';
  const fields = ['title','poster','subtitle','description','rating','quality','releasedAt','trending','pinned'];
  fields.forEach(k=>{
    const val = obj[k] !== undefined ? obj[k] : '';
    const wrapper = document.createElement('div');
    const label = document.createElement('label');
    label.className = 'text-xs font-semibold';
    label.textContent = k;
    wrapper.appendChild(label);

    if(typeof val === 'boolean'){
      const cbWrap = document.createElement('div');
      cbWrap.className = 'mt-1';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.setAttribute('data-key', k);
      if(val) cb.checked = true;
      cbWrap.appendChild(cb);
      wrapper.appendChild(cbWrap);
    } else {
      const inp = document.createElement('input');
      inp.setAttribute('data-key', k);
      inp.className = 'border p-1 rounded w-full mt-1';
      inp.value = val;
      wrapper.appendChild(inp);
    }
    fieldForm.appendChild(wrapper);
  });

  const dl = Array.isArray(obj.downloadLinks) ? obj.downloadLinks : [];
  const dlWrap = document.createElement('div');
  dlWrap.innerHTML = '<label class="text-xs font-semibold mt-2">downloadLinks (text / url)</label>';
  const dlList = document.createElement('div');
  dlList.className = 'space-y-1 mt-1';
  dl.forEach((it, idx)=>{
    const row = document.createElement('div');
    row.className = 'flex gap-2';
    const t = document.createElement('input');
    t.setAttribute('data-key', `dl_text_${idx}`);
    t.className = 'border p-1 rounded flex-1';
    t.value = it.text || '';
    const u = document.createElement('input');
    u.setAttribute('data-key', `dl_url_${idx}`);
    u.className = 'border p-1 rounded flex-1';
    u.value = it.url || '';
    row.appendChild(t);
    row.appendChild(u);
    dlList.appendChild(row);
  });
  const addBtn = document.createElement('button');
  addBtn.className = 'bg-gray-200 px-2 py-1 rounded text-sm mt-2';
  addBtn.textContent = 'Add Link';
  addBtn.addEventListener('click', (e)=>{
    e.preventDefault();
    const idx = (fieldForm.querySelectorAll('[data-key^="dl_text_"]').length);
    const row = document.createElement('div');
    row.className = 'flex gap-2';
    const t = document.createElement('input');
    t.setAttribute('data-key', `dl_text_${idx}`);
    t.className = 'border p-1 rounded flex-1';
    t.value = '';
    const u = document.createElement('input');
    u.setAttribute('data-key', `dl_url_${idx}`);
    u.className = 'border p-1 rounded flex-1';
    u.value = '';
    row.appendChild(t); row.appendChild(u);
    dlList.appendChild(row);
  });

  dlWrap.appendChild(dlList);
  dlWrap.appendChild(addBtn);
  fieldForm.appendChild(dlWrap);
}

/* apply changes from fieldForm into rawJson and save */
btnApply.addEventListener('click', async ()=>{
  try{
    const obj = JSON.parse(rawJson.value);
    fieldForm.querySelectorAll('[data-key]').forEach(el=>{
      const key = el.getAttribute('data-key');
      if(key.startsWith('dl_text_') || key.startsWith('dl_url_')) return;
      if(el.type === 'checkbox') obj[key] = el.checked;
      else obj[key] = el.value;
    });
    const dlTextEls = Array.from(fieldForm.querySelectorAll('[data-key^="dl_text_"]'));
    const dl = [];
    for(const tEl of dlTextEls){
      const idx = tEl.getAttribute('data-key').split('_').pop();
      const urlEl = fieldForm.querySelector(`[data-key="dl_url_${idx}"]`);
      const text = (tEl.value || '').trim();
      const url = (urlEl && urlEl.value) ? urlEl.value.trim() : '';
      if(url) dl.push({ text, url });
    }
    if(dl.length) obj.downloadLinks = dl;
    else delete obj.downloadLinks;

    const jsonStr = JSON.stringify(obj, null, 2);
    rawJson.value = jsonStr;

    await db.ref(currentEdit.path).set(obj);
    editorMsg.textContent = 'Saved ✓';

    // update local caches and idb
    const idx = dbCache.findIndex(h => h.path === currentEdit.path);
    if(idx !== -1) dbCache[idx].data = obj;
    const hitIdx = allHits.findIndex(h => h.path === currentEdit.path);
    if(hitIdx !== -1) allHits[hitIdx].data = obj;
    const toStore = { path: currentEdit.path, key: currentEdit.path.split('/').pop(), data: obj };
    updateIndexedDBItem(toStore).catch(()=>{});
    renderResults();
  }catch(e){
    editorMsg.textContent = 'Error: ' + (e.message || e);
  }
});

btnClose.addEventListener('click', closeEditor);

async function doDelete(path){
  if(!confirm('Delete node at ' + path + ' ?')) return;
  try{
    await db.ref(path).remove();
    allHits = allHits.filter(h => h.path !== path);
    dbCache = dbCache.filter(h => h.path !== path);
    deleteIndexedDBItem(path).catch(()=>{});
    renderResults();
    alert('Deleted ✓');
  }catch(e){
    alert('Delete error: ' + (e.message || e));
  }
}

btnDelete.addEventListener('click', async ()=>{
  if(!confirm('Delete current node?')) return;
  try{
    await db.ref(currentEdit.path).remove();
    editorMsg.textContent = 'Deleted ✓';
    allHits = allHits.filter(h => h.path !== currentEdit.path);
    dbCache = dbCache.filter(h => h.path !== currentEdit.path);
    deleteIndexedDBItem(currentEdit.path).catch(()=>{});
    renderResults();
    closeEditor();
  }catch(e){
    editorMsg.textContent = 'Delete error: ' + (e.message || e);
  }
});

/* pagination */
prevPage.addEventListener('click', ()=> {
  if(page > 0){ page--; renderResults(); }
});
nextPage.addEventListener('click', ()=> {
  const perPage = parseInt(perPageSel.value || 10);
  if((page+1) * perPage < allHits.length){ page++; renderResults(); }
});

/* bind search */
btnSearch.addEventListener('click', doSearch);
btnClear.addEventListener('click', ()=>{
  qInput.value = ''; modeSelect.value = 'field'; resultsTbody.innerHTML = ''; allHits = []; summary.textContent = 'Cleared';
});

/* live suggestions while typing (debounced) */
qInput.addEventListener('input', debounce(async ()=>{
  const q = qInput.value.trim();
  if(!q) { suggestionsDiv.innerHTML = ''; return; }
  try{
    // lightweight suggestion: prefer key-prefix query (fast)
    const suggestions = await queryByKeyPrefix(DEFAULT_BASE, q, 10);
    suggestionsDiv.innerHTML = '';
    suggestions.slice(0,6).forEach(h=>{
      const b = document.createElement('button');
      b.className = 'px-3 py-1 bg-gray-100 rounded text-sm';
      b.textContent = h.key + ' → ' + (h.data && h.data.title ? h.data.title : '');
      b.addEventListener('click', ()=> { qInput.value = h.key; modeSelect.value = 'path'; doSearch(); });
      suggestionsDiv.appendChild(b);
    });
  }catch(e){ /* ignore */ }
}, 300));

/* keyboard: enter triggers search */
qInput.addEventListener('keydown', (e)=> { if(e.key === 'Enter'){ e.preventDefault(); doSearch(); } });

</script>
</body>
</html>
